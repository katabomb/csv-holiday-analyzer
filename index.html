<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>CSV人数：平日(曜日別)・年末年始/お盆(日付別)・その他祝日 平均</title>
  <style>
    :root { font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans JP", sans-serif; }
    body { margin: 20px; line-height: 1.5; }
    h1 { font-size: 18px; margin: 0 0 10px; }
    .row { display:flex; gap:16px; flex-wrap:wrap; }
    .card { border:1px solid #ddd; border-radius:12px; padding:14px; min-width: 320px; flex:1; }
    .muted { color:#666; font-size: 12px; }
    textarea, input[type="text"], input[type="number"] { width: 100%; box-sizing: border-box; }
    textarea { height: 90px; }
    table { border-collapse: collapse; width: 100%; }
    th, td { border:1px solid #ddd; padding:6px 8px; font-size: 13px; }
    th { background:#f7f7f7; text-align:left; }
    .drop { border:2px dashed #bbb; border-radius:12px; padding:16px; text-align:center; }
    .drop.drag { border-color:#333; }
    .btns { display:flex; gap:10px; flex-wrap:wrap; margin-top: 10px; }
    button { padding:8px 12px; border-radius:10px; border:1px solid #ccc; background:#fff; cursor:pointer; }
    button:hover { border-color:#888; }
    .ok { color:#0a6; font-weight:600; }
    .warn { color:#b60; font-weight:600; }
    code { background:#f2f2f2; padding: 0 4px; border-radius:6px; }
  </style>
</head>
<body>
  <h1>CSV人数集計：平日(曜日別) / 年末年始・お盆(日付別) / その他祝日(平均)</h1>
  <p class="muted">
    CSV想定：<code>date,count</code>（例：2023-04-01,15）または2列（1列目=日付、2列目=人数）。
    日付形式は <code>YYYY-MM-DD</code> 推奨（<code>YYYY/MM/DD</code> も可）。
  </p>

  <div class="row">
    <div class="card">
      <div id="drop" class="drop">
        <div><strong>CSVをドラッグ＆ドロップ</strong> または <input id="file" type="file" accept=".csv,text/csv" /></div>
        <div class="muted">複数年の連続日付データ（欠損日があっても可）</div>
      </div>

      <div class="btns">
        <button id="run" disabled>集計する</button>
        <button id="demo">デモデータで試す</button>
        <button id="download" disabled>結果CSVをダウンロード</button>
      </div>

      <div style="margin-top:10px" class="muted">
        読み込み行数：<span id="nrows">0</span> ／ 期間：<span id="span">-</span> ／ 解析：<span id="status">未</span>
      </div>
      <div style="margin-top:6px" class="muted">
        注意：五輪特例などで祝日移動があった年は、必要なら「例外日」に追加して補正してください。
      </div>
    </div>

    <div class="card">
      <h2 style="font-size:14px;margin:0 0 8px;">休日判定の設定</h2>

      <label class="muted">年末年始（既定：12/29〜1/3）</label>
      <div class="row" style="gap:10px; margin-top:6px;">
        <div style="flex:1; min-width:140px;">
          <label class="muted">開始 (MM-DD)</label>
          <input id="ynyStart" type="text" value="12-29" />
        </div>
        <div style="flex:1; min-width:140px;">
          <label class="muted">終了 (MM-DD)</label>
          <input id="ynyEnd" type="text" value="01-03" />
        </div>
      </div>

      <div style="height:10px"></div>

      <label class="muted">お盆（既定：8/13〜8/16）</label>
      <div class="row" style="gap:10px; margin-top:6px;">
        <div style="flex:1; min-width:140px;">
          <label class="muted">開始 (MM-DD)</label>
          <input id="obonStart" type="text" value="08-13" />
        </div>
        <div style="flex:1; min-width:140px;">
          <label class="muted">終了 (MM-DD)</label>
          <input id="obonEnd" type="text" value="08-16" />
        </div>
      </div>

      <div style="height:10px"></div>

      <label class="muted">祝日・特例など「手動追加（例外日）」(YYYY-MM-DD を改行区切り)</label>
      <textarea id="extraHolidays" placeholder="例：2021-07-22&#10;2021-07-23"></textarea>

      <div class="muted" style="margin-top:6px;">
        ※ここに入れた日付は強制的に「祝日」扱い（年末年始/お盆に入っていればそちら優先）
      </div>
    </div>
  </div>

  <div class="row" style="margin-top:16px;">
    <div class="card">
      <h2 style="font-size:14px;margin:0 0 8px;">結果</h2>
      <div id="out"></div>
    </div>
  </div>

<script>
(() => {
  // ---------- Utilities ----------
  const pad2 = n => String(n).padStart(2, "0");
  const ymd = (d) => `${d.getFullYear()}-${pad2(d.getMonth()+1)}-${pad2(d.getDate())}`;
  const md  = (d) => `${pad2(d.getMonth()+1)}-${pad2(d.getDate())}`;
  const parseDate = (s) => {
    const t = String(s).trim();
    if (!t) return null;
    // YYYY-MM-DD or YYYY/MM/DD
    const m = t.match(/^(\d{4})[-\/](\d{1,2})[-\/](\d{1,2})$/);
    if (!m) return null;
    const y = +m[1], mo = +m[2], da = +m[3];
    const d = new Date(y, mo-1, da);
    if (d.getFullYear() !== y || d.getMonth() !== mo-1 || d.getDate() !== da) return null;
    return d;
  };
  const parseMD = (s) => {
    const t = String(s).trim();
    const m = t.match(/^(\d{1,2})[-\/](\d{1,2})$/);
    if (!m) return null;
    const mo = +m[1], da = +m[2];
    if (mo < 1 || mo > 12 || da < 1 || da > 31) return null;
    return `${pad2(mo)}-${pad2(da)}`;
  };

  // ---------- Japanese holiday rules (approx but practical) ----------
  // Weekend: Sat/Sun
  // National holidays:
  // - Fixed: 01/01, 02/11, 02/23, 04/29, 05/03, 05/04, 05/05, 08/11, 11/03, 11/23
  // - Happy Monday: 成人の日(2nd Mon Jan), 海の日(3rd Mon Jul), 敬老の日(3rd Mon Sep), スポーツの日(2nd Mon Oct)
  // - 春分/秋分: approximation formula (valid for modern years; small risk around far future)
  // Substitute holiday: if holiday on Sunday => next weekday becomes holiday
  // Citizen's holiday: a weekday between two holidays becomes holiday
  //
  // NOTE: 特例（五輪移動など）は extraHolidays で補正できるようにする。

  const nthWeekdayOfMonth = (year, month0, weekday0, nth) => {
    // month0: 0-11, weekday0: 0(Sun)-6, nth: 1..5
    const first = new Date(year, month0, 1);
    const shift = (weekday0 - first.getDay() + 7) % 7;
    const day = 1 + shift + 7 * (nth - 1);
    const d = new Date(year, month0, day);
    return (d.getMonth() === month0) ? d : null;
  };

  const vernalEquinoxDay = (y) => {
    // Approx for Japan (1980-2099 commonly used). We'll extend with reasonable fallback.
    // Source-like common formula:
    // 1980-2099: floor(20.8431 + 0.242194*(y-1980) - floor((y-1980)/4))
    const a = y - 1980;
    return Math.floor(20.8431 + 0.242194 * a - Math.floor(a / 4));
  };
  const autumnEquinoxDay = (y) => {
    // 1980-2099: floor(23.2488 + 0.242194*(y-1980) - floor((y-1980)/4))
    const a = y - 1980;
    return Math.floor(23.2488 + 0.242194 * a - Math.floor(a / 4));
  };

  const baseHolidaySetForYear = (year) => {
    const set = new Set();

    const add = (m, d) => set.add(`${year}-${pad2(m)}-${pad2(d)}`);

    // Fixed holidays (modern Japan; ignores historical changes pre-2000s etc)
    add(1,1);      // 元日
    add(2,11);     // 建国記念の日
    add(2,23);     // 天皇誕生日 (current era; older datasets may differ)
    add(4,29);     // 昭和の日
    add(5,3); add(5,4); add(5,5); // GW
    add(8,11);     // 山の日
    add(11,3);     // 文化の日
    add(11,23);    // 勤労感謝の日

    // Happy Monday holidays
    const comingOfAge = nthWeekdayOfMonth(year, 0, 1, 2); // Jan 2nd Monday
    if (comingOfAge) set.add(ymd(comingOfAge));

    const marineDay = nthWeekdayOfMonth(year, 6, 1, 3); // Jul 3rd Monday
    if (marineDay) set.add(ymd(marineDay));

    const respectAged = nthWeekdayOfMonth(year, 8, 1, 3); // Sep 3rd Monday
    if (respectAged) set.add(ymd(respectAged));

    const sportsDay = nthWeekdayOfMonth(year, 9, 1, 2); // Oct 2nd Monday
    if (sportsDay) set.add(ymd(sportsDay));

    // Equinox
    const ve = new Date(year, 2, vernalEquinoxDay(year)); // Mar
    set.add(ymd(ve));
    const ae = new Date(year, 8, autumnEquinoxDay(year)); // Sep
    set.add(ymd(ae));

    // Substitute holiday (振替休日): if a holiday falls on Sunday, the next non-holiday weekday becomes holiday
    // We'll apply iteratively for safety.
    const sorted = Array.from(set).sort();
    const isHolidayYMD = (s) => set.has(s);
    for (const s of sorted) {
      const d = parseDate(s);
      if (!d) continue;
      if (d.getDay() === 0) { // Sunday
        let dd = new Date(d);
        while (true) {
          dd.setDate(dd.getDate() + 1);
          const ss = ymd(dd);
          const dow = dd.getDay();
          // substitute can land on weekday; if it lands on another holiday, keep moving
          if (dow === 0) continue;
          if (!isHolidayYMD(ss)) { set.add(ss); break; }
        }
      }
    }

    // Citizen's holiday (国民の休日): a weekday sandwiched between two holidays becomes holiday
    // We'll scan all dates of the year.
    const start = new Date(year, 0, 1);
    const end = new Date(year, 11, 31);
    for (let d = new Date(start); d <= end; d.setDate(d.getDate() + 1)) {
      const dow = d.getDay();
      if (dow === 0 || dow === 6) continue;
      const s = ymd(d);
      if (set.has(s)) continue;
      const prev = new Date(d); prev.setDate(prev.getDate()-1);
      const next = new Date(d); next.setDate(next.getDate()+1);
      if (set.has(ymd(prev)) && set.has(ymd(next))) set.add(s);
    }

    return set;
  };

  const holidayCache = new Map();
  const getHolidaySet = (year) => {
    if (!holidayCache.has(year)) holidayCache.set(year, baseHolidaySetForYear(year));
    return holidayCache.get(year);
  };

  // ---------- Parsing CSV ----------
  function parseCSV(text) {
    // minimal CSV parser: supports comma, quotes.
    const rows = [];
    let i = 0, field = "", row = [], inQuotes = false;
    while (i < text.length) {
      const c = text[i];
      if (inQuotes) {
        if (c === '"') {
          if (text[i+1] === '"') { field += '"'; i += 2; continue; }
          inQuotes = false; i++; continue;
        }
        field += c; i++; continue;
      } else {
        if (c === '"') { inQuotes = true; i++; continue; }
        if (c === ',') { row.push(field); field = ""; i++; continue; }
        if (c === '\n') { row.push(field); rows.push(row); row = []; field = ""; i++; continue; }
        if (c === '\r') { i++; continue; }
        field += c; i++; continue;
      }
    }
    row.push(field); rows.push(row);

    // normalize: remove empty trailing lines
    while (rows.length && rows[rows.length-1].every(x => String(x).trim()==="")) rows.pop();

    // detect header: if first row contains non-date in col0 or non-number in col1
    let start = 0;
    if (rows.length) {
      const d0 = parseDate(rows[0][0]);
      const n0 = Number(String(rows[0][1] ?? "").trim());
      const looksHeader = !d0 || Number.isNaN(n0);
      if (looksHeader) start = 1;
    }

    const data = [];
    for (let r = start; r < rows.length; r++) {
      const a = rows[r];
      if (!a || a.length < 2) continue;
      const d = parseDate(a[0]);
      const v = Number(String(a[1]).trim());
      if (!d || Number.isNaN(v)) continue;
      data.push({ date: d, count: v });
    }
    data.sort((x,y) => x.date - y.date);
    return data;
  }

  // ---------- Aggregation ----------
  function inRangeByMD(mdStr, startMD, endMD) {
    // handles wrap-around (e.g. 12-29..01-03)
    if (startMD <= endMD) return (mdStr >= startMD && mdStr <= endMD);
    return (mdStr >= startMD || mdStr <= endMD);
  }

  function mean(arr) {
    if (!arr.length) return null;
    let s = 0;
    for (const x of arr) s += x;
    return s / arr.length;
  }

  function fmt(x) {
    if (x === null) return "";
    // show with 2 decimals max but trim trailing zeros
    return (Math.round(x * 100) / 100).toFixed(2).replace(/\.00$/,"").replace(/(\.\d)0$/,"$1");
  }

  function aggregate(data, cfg) {
    const { ynyStart, ynyEnd, obonStart, obonEnd, extra } = cfg;

    const byWeekday = Array.from({length:7}, () => []);
    const ynyByMD = new Map();  // md -> counts
    const obonByMD = new Map(); // md -> counts
    const otherHoliday = [];    // counts (national holidays excluding yny/obon ranges)
    const stats = { total: data.length, years: new Set() };

    const extraSet = new Set(extra);

    for (const {date, count} of data) {
      const year = date.getFullYear();
      stats.years.add(year);

      const s = ymd(date);
      const mdStr = md(date);
      const dow = date.getDay(); // 0 Sun ... 6 Sat

      const isWeekend = (dow === 0 || dow === 6);
      const holidaySet = getHolidaySet(year);
      const isNatHoliday = holidaySet.has(s) || extraSet.has(s);

      const isYNY = inRangeByMD(mdStr, ynyStart, ynyEnd);
      const isObon = inRangeByMD(mdStr, obonStart, obonEnd);

      if (isYNY) {
        if (!ynyByMD.has(mdStr)) ynyByMD.set(mdStr, []);
        ynyByMD.get(mdStr).push(count);
        continue;
      }
      if (isObon) {
        if (!obonByMD.has(mdStr)) obonByMD.set(mdStr, []);
        obonByMD.get(mdStr).push(count);
        continue;
      }

      if (isWeekend) continue;

      if (isNatHoliday) {
        otherHoliday.push(count);
      } else {
        byWeekday[dow].push(count);
      }
    }

    const weekdayNames = ["日","月","火","水","木","金","土"];
    const weekdayTable = [];
    for (let dow=1; dow<=5; dow++) {
      const arr = byWeekday[dow];
      weekdayTable.push({
        label: `${weekdayNames[dow]}曜(平日)`,
        n: arr.length,
        mean: mean(arr)
      });
    }

    const expandRangeMD = (startMD, endMD) => {
      // expand MD range within a dummy year (non-leap safe)
      // We'll iterate dates in 2001 (non-leap) and wrap if needed.
      const y = 2001;
      const [sm, sd] = startMD.split("-").map(Number);
      const [em, ed] = endMD.split("-").map(Number);

      const start = new Date(y, sm-1, sd);
      const end = new Date(y, em-1, ed);

      const res = [];
      if (startMD <= endMD) {
        for (let d = new Date(start); d <= end; d.setDate(d.getDate()+1)) res.push(md(d));
      } else {
        // wrap: start..12/31 plus 01/01..end
        const end1 = new Date(y, 11, 31);
        for (let d = new Date(start); d <= end1; d.setDate(d.getDate()+1)) res.push(md(d));
        const start2 = new Date(y, 0, 1);
        for (let d = new Date(start2); d <= end; d.setDate(d.getDate()+1)) res.push(md(d));
      }
      return res;
    };

    const ynyOrder = expandRangeMD(ynyStart, ynyEnd);
    const obonOrder = expandRangeMD(obonStart, obonEnd);

    const ynyTable = ynyOrder.map(k => {
      const arr = ynyByMD.get(k) || [];
      return { label: `年末年始 ${k}`, n: arr.length, mean: mean(arr) };
    });
    const obonTable = obonOrder.map(k => {
      const arr = obonByMD.get(k) || [];
      return { label: `お盆 ${k}`, n: arr.length, mean: mean(arr) };
    });

    return {
      stats,
      weekdayTable,
      ynyTable,
      obonTable,
      otherHoliday: { label: "祝祭日(年末年始・お盆以外) 平均", n: otherHoliday.length, mean: mean(otherHoliday) }
    };
  }

  // ---------- UI ----------
  const $ = (id) => document.getElementById(id);
  const elDrop = $("drop");
  const elFile = $("file");
  const elRun = $("run");
  const elDemo = $("demo");
  const elDownload = $("download");
  const elOut = $("out");
  const elNrows = $("nrows");
  const elSpan = $("span");
  const elStatus = $("status");

  const elYnyStart = $("ynyStart");
  const elYnyEnd = $("ynyEnd");
  const elObonStart = $("obonStart");
  const elObonEnd = $("obonEnd");
  const elExtra = $("extraHolidays");

  let currentData = [];
  let lastResultCSV = "";

  function setStatus(text, cls="") {
    elStatus.textContent = text;
    elStatus.className = cls;
  }

  function updateMeta() {
    elNrows.textContent = String(currentData.length);
    if (currentData.length) {
      elSpan.textContent = `${ymd(currentData[0].date)} 〜 ${ymd(currentData[currentData.length-1].date)}`;
      elRun.disabled = false;
      setStatus("準備OK", "ok");
    } else {
      elSpan.textContent = "-";
      elRun.disabled = true;
      setStatus("未", "");
    }
  }

  function readExtraDates() {
    const lines = elExtra.value.split(/\r?\n/).map(x=>x.trim()).filter(Boolean);
    const out = [];
    for (const s of lines) {
      const d = parseDate(s);
      if (d) out.push(ymd(d));
    }
    return out;
  }

  function renderTables(res) {
    const years = Array.from(res.stats.years).sort((a,b)=>a-b);
    const yearStr = years.length ? `${years[0]}〜${years[years.length-1]}（${years.length}年分）` : "-";

    const makeTable = (rows) => {
      const tr = rows.map(r => `
        <tr>
          <td>${r.label}</td>
          <td>${r.n}</td>
          <td>${fmt(r.mean)}</td>
        </tr>`).join("");
      return `<table>
        <thead><tr><th>区分</th><th>件数</th><th>平均人数</th></tr></thead>
        <tbody>${tr}</tbody>
      </table>`;
    };

    const other = res.otherHoliday;

    const warn = (() => {
      // if any key date in yny/obon has 0 samples, mention
      const missing = [...res.ynyTable, ...res.obonTable].filter(r => r.n === 0).length;
      if (missing > 0) return `<div class="muted"><span class="warn">注意</span>：年末年始/お盆の一部日付でサンプル0件（CSVにその日が無いか、日付範囲設定が合っていません）</div>`;
      return "";
    })();

    elOut.innerHTML = `
      <div class="muted">対象年：${yearStr} ／ 入力行：${res.stats.total}</div>
      ${warn}
      <h3 style="font-size:13px;margin:12px 0 6px;">平日：曜日別 平均</h3>
      ${makeTable(res.weekdayTable)}
      <h3 style="font-size:13px;margin:12px 0 6px;">年末年始：日付別 平均</h3>
      ${makeTable(res.ynyTable)}
      <h3 style="font-size:13px;margin:12px 0 6px;">お盆：日付別 平均</h3>
      ${makeTable(res.obonTable)}
      <h3 style="font-size:13px;margin:12px 0 6px;">祝祭日（年末年始・お盆以外）</h3>
      ${makeTable([other])}
      <div class="muted" style="margin-top:10px;">
        ※「平日」は <strong>土日・祝日・年末年始・お盆</strong> を除外。<br/>
        ※「祝祭日」は <strong>土日</strong> は除外し、<strong>年末年始・お盆</strong> に該当する日付はそちらに回します。
      </div>
    `;
  }

  function buildResultCSV(res) {
    const lines = [];
    lines.push(["category","n","mean"].join(","));
    for (const r of res.weekdayTable) lines.push([r.label, r.n, fmt(r.mean)].join(","));
    for (const r of res.ynyTable)     lines.push([r.label, r.n, fmt(r.mean)].join(","));
    for (const r of res.obonTable)    lines.push([r.label, r.n, fmt(r.mean)].join(","));
    lines.push([res.otherHoliday.label, res.otherHoliday.n, fmt(res.otherHoliday.mean)].join(","));
    return lines.join("\n");
  }

  function run() {
    const ynyStart = parseMD(elYnyStart.value);
    const ynyEnd   = parseMD(elYnyEnd.value);
    const obonStart= parseMD(elObonStart.value);
    const obonEnd  = parseMD(elObonEnd.value);
    if (!ynyStart || !ynyEnd || !obonStart || !obonEnd) {
      alert("年末年始/お盆の範囲は MM-DD 形式で入力してください（例：12-29）");
      return;
    }
    const extra = readExtraDates();
    const res = aggregate(currentData, { ynyStart, ynyEnd, obonStart, obonEnd, extra });
    renderTables(res);
    lastResultCSV = buildResultCSV(res);
    elDownload.disabled = !lastResultCSV;
    setStatus("完了", "ok");
  }

  function setDataFromText(text) {
    currentData = parseCSV(text);
    updateMeta();
    elOut.innerHTML = "";
    elDownload.disabled = true;
    lastResultCSV = "";
  }

  // DnD
  elDrop.addEventListener("dragover", (e) => { e.preventDefault(); elDrop.classList.add("drag"); });
  elDrop.addEventListener("dragleave", () => elDrop.classList.remove("drag"));
  elDrop.addEventListener("drop", async (e) => {
    e.preventDefault();
    elDrop.classList.remove("drag");
    const f = e.dataTransfer.files?.[0];
    if (!f) return;
    const text = await f.text();
    setDataFromText(text);
  });

  // file input
  elFile.addEventListener("change", async () => {
    const f = elFile.files?.[0];
    if (!f) return;
    const text = await f.text();
    setDataFromText(text);
  });

  // buttons
  elRun.addEventListener("click", run);

  elDemo.addEventListener("click", () => {
    // Create demo: 3 years daily data with simple seasonality
    const start = new Date(2022,0,1);
    const end   = new Date(2024,11,31);
    const lines = ["date,count"];
    for (let d = new Date(start); d <= end; d.setDate(d.getDate()+1)) {
      const dow = d.getDay();
      let base = 20 + (dow===1?5:0) + (dow===5?3:0); // Mon/Fri bump
      // winter up
      if (d.getMonth()<=1 || d.getMonth()===11) base += 3;
      // random-ish deterministic noise
      const noise = ((d.getFullYear()*10000 + (d.getMonth()+1)*100 + d.getDate()) % 7) - 3;
      const val = Math.max(0, Math.round(base + noise));
      lines.push(`${ymd(d)},${val}`);
    }
    setDataFromText(lines.join("\n"));
  });

  elDownload.addEventListener("click", () => {
    if (!lastResultCSV) return;
    const blob = new Blob([lastResultCSV], {type:"text/csv;charset=utf-8"});
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = "summary_averages.csv";
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(a.href);
  });

  setStatus("未", "");
})();
</script>
</body>
</html>
